#골드5 평범한 배낭

#1차시도 (실패)
#include <iostream>
#include <set>
#include <utility>
using namespace std;

int main(void) {
    int n,k;
    cin >> n >> k;
    set<pair<int, int>> arr;

    int N = n;
    while(N--){
        int w, v;
        cin >> w >> v;
        arr.insert(pair<int, int>(-w,v));
    }

    int answer = 0;
    for(int i=0; i<n; i++){
        int K = k;
        int V = 0;
        for (auto a : arr){
            if(K+a.first >= 0) {
                K += a.first;
                V += a.second;
            }
        }
        if (answer < V)
            answer = V;
        arr.erase(arr.begin());
    }
    cout << answer << endl;
    return 0;
}
넣을 수 있는 가장 큰 물건부터 넣으면서 가치를 비교하는 방식으로
탐욕법과 비슷한 알고리즘을 가지고 풀었다고 생각했으나 실패했다.
물건의 무게와 가치가 정비례할거라는 착각을 한것 같다.

#2차시도 (실패)
#include <iostream>
#include <vector>
#include <utility>
using namespace std;

void combination(int depth, int next, int n, int r, vector<vector<int>> &all, vector<int> t) {
    if (depth == r) {
        all.push_back(t);
        return;
    }
    for (int i=next; i<n; i++){
        t[depth] = i;
        combination(depth+1, i+1, n, r, all, t);
    }
}
int main(void) {
    int n,k;
    cin >> n >> k;
    vector<pair<int, int>> arr;
    int N = n;
    while(N--){
        int w, v;
        cin >> w >> v;
        arr.push_back(pair<int, int>(w,v));
    }
    vector<vector<int>> com;
    for (int i=1; i<=n; i++)
        combination(0, 0, n, i, com, vector<int>(i));
    int answer = 0;
    for (auto c : com){
        int s = 0;
        int v = 0;
        
        for (auto i : c) {
            v += arr[i].first;
            s += arr[i].second;
        }
        if (v <= k && s > answer)
            answer = s;
    }
    cout << answer;
    return 0;
}
고민해본 결과 조합을 통해 모든 조합을 확인해야 할 것 같다고 판단하여 조합을구하고
계산해보았지만 정해진 메모리를 초과하는 문제가 발생했다.
#LV3 양과 늑대

#1차시도 (실패)
import heapq
def counting(nodes, i):
    nodes[i][0] = nodes[i][1]-1
    if nodes[i][2] == []:
        if nodes[i][1]:
            return 0
        else:
            return -1
    for j in nodes[i][2]:
        nodes[i][0] += counting(nodes, j)
    return nodes[i][0]

def solution(info, edges):
    nodes = {i:[0,f,[]] for i,f in enumerate(info)}
    for p, c in edges:
        nodes[p][2].append(c)
    counting(nodes, 0)
    
    que = [nodes[0]]
    heapq.heapify(que)
    s, w = 0, 0
    while que:
        heapq.heapify(que)
        checker = que.copy()
        temp = []

        while que:
            n = heapq.heappop(que)
            if n[1] == 0:
                s+=1
                for i in n[2]:
                    heapq.heappush(temp, nodes[i])
            elif s > w+1 and n[2] != []:
                w+=1
                for i in n[2]:
                    heapq.heappush(temp, nodes[i])
            else:
                heapq.heappush(temp, n)
        if temp == checker:
            break
        que = temp
    return s
현재 노드에서 자식의 양의 개수를 저장하고 
heapq로 우선순위를 설정하고 bfs 알고리즘을 응용하여 탐색하도록 코드를 작성해봤다.
3분의 2정도의 케이스에서 실패했다. 우선 순위를 설정하는 방법이 잘 못된듯 하다.


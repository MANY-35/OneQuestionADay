#LV3 연속 펄스 부분 수열의 합

#1차시도 (실패)
long long solution(vector<int> sequence) {
    int len = sequence.size();
    long long a1, a2;
    long long max = 0;
    for (int i=0; i<len-1; i++){
        a1 = a2 = 0;
        int flag = 1;
        for (int j=i; j<len; j++) {
            a1 += sequence[j] * flag;
            a2 += sequence[j] * (-flag);
            if (a1 > max) {
                max = a1;
            }
            if (a2 > max) {
                max = a2;
            } 
            flag = -flag;
        }
    }
    return max;
}
단순하게 생각해서 길이가 50만 이기 때문에 O(n^2) 정도여도 할만하다고 생각하여
순열을 완전탐색 하여 1과 -1 로 시작하는 두 펄스 수열을 동시에 계산해가면서 큰값을 저장하는
방식으로 작성했으나 하나의 케이스에서 실패햇으며
(아마 첫 반복문을 len-1 로 하여 시간을 조금이나마 줄여보려 했으나 배열의 길이가 1일경우 문제가 생기는것 같다)
4개의 케이스에서 시간이 초과가 발생했다.

#2차시도 (실패)
long long solution(vector<int> sequence) {
    long long answer = 0;
    int len = sequence.size();
    vector<long long> arr(len);

    arr[0] = sequence[0];
    for(int i=1, flag=-1; i<len; i++) {
        if (arr[i-1] + sequence[i]*flag < sequence[i]) {
            flag = -1;
            arr[i] = sequence[i];
        } else {
            arr[i] = arr[i-1] + sequence[i]*flag;
            flag = -flag;
        }
        if (arr[i] > answer)
            answer = arr[i];
    }
    return answer;
}
시간을 줄이고자 DP알고리즘을 응용하여 코드를 작성해 보았으나 뭔가 잘못 설계한것 같다.
대부분의 케이스에서 실패했다.